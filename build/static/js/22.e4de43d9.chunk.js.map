{"version":3,"sources":["app/components/conference/WebCall.js"],"names":["signalingSocket","localMediaStream","peers","peerMediaElements","WebCall","props","setFocusedPeer","key","state","is_admin","displayMessage","WARNING_MSG_TYPE","setState","focusedPeer","send","admin","peer_id","loadMeeting","meetingId","that","getAPI","interpolate","SINGLE_MEETING","data","admins","forEach","doctor","user","staff","id","meetingDetails","changeChannel","meeting_id","value","DEFAULT_CHANNEL","init","console","log","SIGNALING_SERVER","ICE_SERVERS","io","on","meetingUserDetails","setupLocalMedia","channel","userdata","emit","config","peer_connection","RTCPeerConnection","onicecandidate","event","candidate","sdpMLineIndex","onaddstream","remote_media","ref","video","srcObject","stream","autoPlay","style","width","prevState","availablePeers","addStream","should_create_offer","createOffer","local_description","setLocalDescription","ERROR_MSG_TYPE","error","peer","remote_description","session_description","userData","is_superuser","myPeerId","desc","RTCSessionDescription","setRemoteDescription","type","createAnswer","ice_candidate","addIceCandidate","RTCIceCandidate","src","close","callback","errorback","navigator","getUserMedia","webkitGetUserMedia","mozGetUserMedia","msGetUserMedia","localMedia","muted","localMediaComponent","alert","url","this","match","params","availablePeersIdArray","Object","keys","minHeight","textAlign","name","justify","gutter","marginTop","me","socket","xs","sm","md","lg","xl","bodyStyle","padding","first_name","map","shape","icon","onClick","float","React","Component"],"mappings":"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","file":"static/js/22.e4de43d9.chunk.js","sourcesContent":["import React from \"react\";\nimport io from 'socket.io-client';\nimport {Button, Card, Col, Row} from \"antd\";\nimport {SINGLE_MEETING} from \"../../constants/api\";\nimport {displayMessage, getAPI, interpolate} from \"../../utils/common\";\nimport {ERROR_MSG_TYPE, WARNING_MSG_TYPE} from \"../../constants/dataKeys\";\n\nlet signalingSocket = null;   /* our socket.io connection to our webserver */\nlet localMediaStream = null; /* our own microphone / webcam */\nlet peers = {};                /* keep track of our peer connections, indexed by peer_id (aka socket.io id) */\nlet peerMediaElements = {};  /* keep track of our <video>/<audio> tags, indexed by peer_id */\nexport default class WebCall extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            myPeerId: null,\n            is_admin: false,\n            meetingDetails: {},\n            SIGNALING_SERVER: \"https://bk-erp.plutonic.co.in\",\n            DEFAULT_CHANNEL: '',\n            ICE_SERVERS: [\n                {url: \"stun:stun.l.google.com:19302\"}\n            ],\n            localMediaComponent: <div />,\n            availablePeers: {},\n            meetingUserDetails: {}\n        }\n    }\n\n    componentDidMount() {\n        if (this.props.match.params && this.props.match.params.meetingId) {\n            this.loadMeeting(this.props.match.params.meetingId);\n        }\n    }\n\n    setFocusedPeer = (key) => {\n        if (!this.state.is_admin) {\n            displayMessage(WARNING_MSG_TYPE, \"You are not allowed for this action.\");\n            return false;\n        }\n        this.setState({\n            focusedPeer: key\n        })\n        signalingSocket.send({admin: key, peer_id: 'admin'});\n    }\n\n    loadMeeting = (meetingId) => {\n        const that = this;\n        const successFn = function (data) {\n            let admin = false;\n            data.admins.forEach(function (doctor) {\n                if (that.props.user.staff && that.props.user.staff.id == doctor) {\n                    admin = true;\n                }\n            });\n            that.setState({\n                meetingDetails: data,\n                is_admin: admin,\n            });\n            that.changeChannel(data.meeting_id);\n        }\n        const errorFn = function () {\n\n        }\n        getAPI(interpolate(SINGLE_MEETING, [meetingId]), successFn, errorFn);\n    }\n\n    changeChannel = (value) => {\n        value = value || 'default';\n        const that = this;\n        this.setState({\n            DEFAULT_CHANNEL: value,\n        }, function () {\n            that.init();\n        })\n    }\n\n    init = () => {\n        const that = this;\n        console.log(\"Connecting to signaling server\");\n        const {SIGNALING_SERVER, DEFAULT_CHANNEL, ICE_SERVERS} = this.state;\n        signalingSocket = io(SIGNALING_SERVER);\n        // signalingSocket = io();\n        signalingSocket.on('message', function (data) {\n            console.log(\"userDetails\", data);\n            console.log(\"admin\", data.admin);\n            that.setState({\n                meetingUserDetails: data\n            })\n        });\n        signalingSocket.on('connect', function () {\n            console.log(\"Connected to signaling server\");\n            that.setupLocalMedia(function () {\n                /* once the user has given us access to their\n                 * microphone/camcorder, join the channel and start peering up */\n                join_chat_channel(DEFAULT_CHANNEL, {'whatever-you-want-here': 'stuff'});\n            });\n        });\n        signalingSocket.on('disconnect', function () {\n            console.log(\"Disconnected from signaling server\");\n            /* Tear down all of our peer connections and remove all the\n             * media divs when we disconnect */\n            // for (peer_id in peerMediaElements) {\n            //     peerMediaElements[peer_id].remove();\n            // }\n            // for (peer_id in peers) {\n            //     peers[peer_id].close();\n            // }\n\n            peers = {};\n            peerMediaElements = {};\n        });\n\n        function join_chat_channel(channel, userdata) {\n            signalingSocket.emit('join', {\"channel\": channel, \"userdata\": userdata});\n        }\n\n        function part_chat_channel(channel) {\n            signalingSocket.emit('part', channel);\n        }\n\n\n        /**\n         * When we join a group, our signaling server will send out 'addPeer' events to each pair\n         * of users in the group (creating a fully-connected graph of users, ie if there are 6 people\n         * in the channel you will connect directly to the other 5, so there will be a total of 15\n         * connections in the network).\n         */\n        signalingSocket.on('addPeer', function (config) {\n            console.log('Signaling server said to add peer:', config);\n            const {peer_id} = config;\n            if (peer_id in peers) {\n                /* This could happen if the user joins multiple channels where the other peer is also in. */\n                console.log(\"Already connected to peer \", peer_id);\n                return;\n            }\n            const peer_connection = new RTCPeerConnection(\n                {\"iceServers\": ICE_SERVERS},\n                {\"optional\": [{\"DtlsSrtpKeyAgreement\": true}]} /* this will no longer be needed by chrome\n                                                                        * eventually (supposedly), but is necessary\n                                                                        * for now to get firefox to talk to chrome */\n            );\n            console.log(\"New Peer Connection\", peer_connection);\n            peers[peer_id] = peer_connection;\n\n\n            peer_connection.onicecandidate = function (event) {\n                if (event.candidate) {\n                    signalingSocket.emit('relayICECandidate', {\n                        'peer_id': peer_id,\n                        'ice_candidate': {\n                            'sdpMLineIndex': event.candidate.sdpMLineIndex,\n                            'candidate': event.candidate.candidate\n                        }\n                    });\n                }\n            }\n            peer_connection.onaddstream = function (event) {\n                console.log(\"onAddStream\", event);\n                const remote_media = (\n                    <video\n                      key={peer_id}\n                      ref={video => {\n                            if (video)\n                                video.srcObject = event.stream\n                        }}\n                      autoPlay\n                      style={{width: '100%'}}\n                    />\n                );\n                peerMediaElements[peer_id] = remote_media;\n                that.setState(function (prevState) {\n                    return {availablePeers: {...prevState.availablePeers, [peer_id]: true}}\n                })\n            }\n            /* Add our local stream */\n            peer_connection.addStream(localMediaStream);\n\n\n            /* Only one side of the peer connection should create the\n             * offer, the signaling server picks one to be the offerer.\n             * The other user will get a 'sessionDescription' event and will\n             * create an offer, then send back an answer 'sessionDescription' to us\n             */\n            if (config.should_create_offer) {\n                console.log(\"Creating RTC offer to \", peer_id);\n                peer_connection.createOffer(\n                    function (local_description) {\n                        console.log(\"Local offer description is: \", local_description);\n                        peer_connection.setLocalDescription(local_description,\n                            function () {\n                                signalingSocket.emit('relaySessionDescription',\n                                    {'peer_id': peer_id, 'session_description': local_description});\n                                console.log(\"Offer setLocalDescription succeeded\");\n                            },\n                            function () {\n                                displayMessage(ERROR_MSG_TYPE, \"Offer setLocalDescription failed!\");\n                            }\n                        );\n                    },\n                    function (error) {\n                        console.log(\"Error sending offer: \", error);\n                    });\n            }\n        });\n\n\n        /**\n         * Peers exchange session descriptions which contains information\n         * about their audio / video settings and that sort of stuff. First\n         * the 'offerer' sends a description to the 'answerer' (with type\n         * \"offer\"), then the answerer sends one back (with type \"answer\").\n         */\n        signalingSocket.on('sessionDescription', function (config) {\n            console.log('Remote description received: ', config);\n            const {peer_id} = config;\n            const peer = peers[peer_id];\n            const remote_description = config.session_description;\n            console.log(config.session_description);\n            const userData = {...that.props.user, peer_id};\n            if (that.state.is_admin || userData.is_superuser) {\n                userData.admin = true;\n                signalingSocket.send({admin: peer_id, peer_id: 'admin'});\n            }\n            that.setState({\n                myPeerId: config.peer_id\n            })\n            signalingSocket.send(userData);\n            const desc = new RTCSessionDescription(remote_description);\n            const stuff = peer.setRemoteDescription(desc,\n                function () {\n                    console.log(\"setRemoteDescription succeeded\");\n                    if (remote_description.type == \"offer\") {\n                        console.log(\"Creating answer\");\n                        peer.createAnswer(\n                            function (local_description) {\n                                console.log(\"Answer description is: \", local_description);\n                                peer.setLocalDescription(local_description,\n                                    function () {\n                                        signalingSocket.emit('relaySessionDescription',\n                                            {'peer_id': peer_id, 'session_description': local_description});\n                                        console.log(\"Answer setLocalDescription succeeded\");\n                                    },\n                                    function () {\n                                        displayMessage(ERROR_MSG_TYPE, \"Answer setLocalDescription failed!\");\n                                    }\n                                );\n                            },\n                            function (error) {\n                                console.log(\"Error creating answer: \", error);\n                                console.log(peer);\n                            });\n                    }\n                },\n                function (error) {\n                    console.log(\"setRemoteDescription error: \", error);\n                }\n            );\n            console.log(\"Description Object: \", desc);\n\n        });\n\n        /**\n         * The offerer will send a number of ICE Candidate blobs to the answerer so they\n         * can begin trying to find the best path to one another on the net.\n         */\n        signalingSocket.on('iceCandidate', function (config) {\n            const peer = peers[config.peer_id];\n            const {ice_candidate} = config;\n            peer.addIceCandidate(new RTCIceCandidate(ice_candidate));\n        });\n\n\n        /**\n         * When a user leaves a channel (or is disconnected from the\n         * signaling server) everyone will recieve a 'removePeer' message\n         * telling them to trash the media channels they have open for those\n         * that peer. If it was this client that left a channel, they'll also\n         * receive the removePeers. If this client was disconnected, they\n         * wont receive removePeers, but rather the\n         * signalingSocket.on('disconnect') code will kick in and tear down\n         * all the peer sessions.\n         */\n        signalingSocket.on('removePeer', function (config) {\n            console.log('Signaling server said to remove peer:', config);\n            const {peer_id} = config;\n            // if (peer_id in peerMediaElements) {\n            peerMediaElements[peer_id] = <video src=\"\" />;\n            // }\n            // if (peer_id in peers) {\n            peers[peer_id].close();\n            // }\n            //\n            delete peers[peer_id];\n            delete peerMediaElements[config.peer_id];\n            that.setState(function (prevState) {\n                const availablePeers = {...prevState.availablePeers};\n                delete availablePeers[peer_id];\n                return {availablePeers: {...availablePeers}}\n            }, function () {\n\n            });\n\n        });\n    }\n\n\n    /** ******************** */\n    /** Local media stuff * */\n    /** ******************** */\n    setupLocalMedia = (callback, errorback) => {\n        const that = this;\n        if (localMediaStream != null) {  /* ie, if we've already been initialized */\n            if (callback) callback();\n            return;\n        }\n        /* Ask user for permission to use the computers microphone and/or camera,\n         * attach it to an <audio> or <video> tag if they give us access. */\n        console.log(\"Requesting access to local audio / video inputs\");\n\n\n        navigator.getUserMedia = (navigator.getUserMedia ||\n            navigator.webkitGetUserMedia ||\n            navigator.mozGetUserMedia ||\n            navigator.msGetUserMedia);\n\n\n        navigator.getUserMedia({\"audio\": true, \"video\": true},\n            function (stream) { /* user accepted access to a/v */\n                console.log(\"Access granted to audio/video\");\n                localMediaStream = stream;\n                const localMedia = (\n                    <video\n                      key=\"me\"\n                      muted\n                      autoPlay\n                      style={{width: '100%'}}\n                      ref={video => {\n                            if (video)\n                                video.srcObject = stream\n                        }}\n                    />\n                );\n                that.setState({\n                    localMediaComponent: localMedia\n                })\n\n                if (callback) callback();\n            },\n            function () { /* user denied access to a/v */\n                console.log(\"Access denied for audio/video\");\n                alert(\"You chose not to provide access to the camera/microphone, demo will not work.\");\n                if (errorback) errorback();\n            });\n    }\n\n    render() {\n        const {localMediaComponent, availablePeers, meetingUserDetails, meetingDetails, myPeerId} = this.state;\n        const availablePeersIdArray = Object.keys(availablePeers);\n        return (\n            <div style={{minHeight: '100vh', textAlign: 'center'}}>\n                <h3>{meetingDetails.name}</h3>\n                <Row type=\"flex\" justify=\"center\" gutter={16} style={{marginTop: 10}}>\n                    {meetingUserDetails.me && meetingUserDetails.me.socket === meetingUserDetails.admin ? (\n                        <Col xs={24} sm={12} md={12} lg={12} xl={12} key={myPeerId}>\n                            <Card bodyStyle={{padding: 0, textAlign: 'center'}}>\n                                {localMediaComponent}\n                                <h4>{meetingUserDetails[meetingUserDetails.admin] ? meetingUserDetails[meetingUserDetails.admin].first_name : '--'} </h4>\n                            </Card>\n                        </Col>\n                    ) : availablePeersIdArray.map(key => {\n                        if (meetingUserDetails.admin === key)\n                            return (\n                                <Col xs={24} sm={12} md={12} lg={12} xl={12} key={key}>\n                                    <Card bodyStyle={{padding: 0, textAlign: 'center'}}>\n                                        {peerMediaElements[key]}\n                                        <h4>{meetingUserDetails[key] ? meetingUserDetails[key].first_name : '--'}\n                                            <Button\n                                              type=\"danger\"\n                                              shape=\"circle\"\n                                              icon=\"close\"\n                                              onClick={() => this.setFocusedPeer(meetingUserDetails.me ? meetingUserDetails.me.socket : null)}\n                                              style={{float: 'right'}}\n                                            />\n                                        </h4>\n                                    </Card>\n                                </Col>\n                            );\n                        return null;\n                    })}\n                    {/* {focusedPeer ? <Col xs={24} sm={12} md={12} lg={12} xl={12} key={focusedPeer}> */}\n                    {/*        <Card bodyStyle={{padding: 0, textAlign: 'center'}}> */}\n                    {/*            {peerMediaElements[focusedPeer]} */}\n                    {/*            <h4>{meetingUserDetails[focusedPeer] ? meetingUserDetails[focusedPeer].first_name : '--'} */}\n                    {/*                <Button type=\"danger\" shape=\"circle\" icon=\"close\" onClick={() => this.setFocusedPeer(myPeerId)} */}\n                    {/*                        style={{float: 'right'}}/> */}\n                    {/*            </h4> */}\n                    {/*        </Card> */}\n                    {/*    </Col> : */}\n                    {/*    null */}\n                    {/* } */}\n                </Row>\n                <Row gutter={16} style={{marginTop: 10}} type=\"flex\" justify=\"center\">\n                    <Col xs={24} sm={12} md={4} lg={4} xl={3}>\n                        <Card key=\"me\" bodyStyle={{padding: 0, textAlign: 'center'}}>\n                            {localMediaComponent}\n                            <h4>ME</h4>\n                        </Card>\n                    </Col>\n                    {availablePeersIdArray.map(key => {\n                        return (\n                            <Col xs={8} sm={8} md={4} lg={4} xl={3} key={key} onClick={() => this.setFocusedPeer(key)}>\n                                <Card bodyStyle={{padding: 0, textAlign: 'center'}}>{peerMediaElements[key]}\n                                    <h4>{meetingUserDetails[key] ? meetingUserDetails[key].first_name : '--'}</h4>\n                                </Card>\n                            </Col>\n                        )\n                    })}\n                </Row>\n            </div>\n        )\n    }\n\n}\n"],"sourceRoot":""}