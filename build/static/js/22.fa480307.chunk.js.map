{"version":3,"sources":["app/components/conference/WebCall.js"],"names":["signalingSocket","localMediaStream","peers","peerMediaElements","WebCall","props","setFocusedPeer","key","state","DEFAULT_CHANNEL","MUTE_CHANNEL","is_admin","displayMessage","WARNING_MSG_TYPE","setState","focusedPeer","send","admin","peer_id","channel","mute","toggleChannelMute","adminKey","loadMeeting","meetingId","that","getAPI","interpolate","SINGLE_MEETING","data","admins","forEach","doctor","user","staff","id","meetingDetails","changeChannel","meeting_id","value","init","console","log","SIGNALING_SERVER","ICE_SERVERS","io","on","meetingUserDetails","setupLocalMedia","userdata","emit","config","peer_connection","RTCPeerConnection","onicecandidate","event","candidate","sdpMLineIndex","onaddstream","remote_media","ref","video","srcObject","stream","autoPlay","controls","muted","style","width","prevState","availablePeers","addStream","should_create_offer","createOffer","local_description","setLocalDescription","ERROR_MSG_TYPE","error","peer","remote_description","session_description","userData","is_superuser","myPeerId","desc","RTCSessionDescription","setRemoteDescription","type","createAnswer","ice_candidate","addIceCandidate","RTCIceCandidate","src","close","callback","errorback","navigator","getUserMedia","webkitGetUserMedia","mozGetUserMedia","msGetUserMedia","localMedia","localMediaComponent","alert","url","username","credential","this","match","params","availablePeersIdArray","Object","keys","minHeight","textAlign","name","justify","gutter","marginTop","me","socket","xs","sm","md","lg","xl","bodyStyle","padding","first_name","map","Group","icon","onClick","theme","twoToneColor","mediaElement","React","Component"],"mappings":"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","file":"static/js/22.fa480307.chunk.js","sourcesContent":["import React from \"react\";\nimport io from 'socket.io-client';\nimport {Button, Card, Col, Icon, Row, Switch} from \"antd\";\nimport {SINGLE_MEETING} from \"../../constants/api\";\nimport {displayMessage, getAPI, interpolate} from \"../../utils/common\";\nimport {ERROR_MSG_TYPE, WARNING_MSG_TYPE} from \"../../constants/dataKeys\";\n\nlet signalingSocket = null;   /* our socket.io connection to our webserver */\nlet localMediaStream = null; /* our own microphone / webcam */\nlet peers = {};                /* keep track of our peer connections, indexed by peer_id (aka socket.io id) */\nlet peerMediaElements = {};  /* keep track of our <video>/<audio> tags, indexed by peer_id */\nexport default class WebCall extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            myPeerId: null,\n            is_admin: false,\n            meetingDetails: {},\n            SIGNALING_SERVER: \"https://bk-erp.plutonic.co.in\",\n            DEFAULT_CHANNEL: '',\n            ICE_SERVERS: [\n                {\n                    url: \"stun:bk-erp.plutonic.co.in:3478\", username: \"test01\",\n                    credential: \"testdriver\"\n                }\n\n            ],\n            localMediaComponent: <div />,\n            availablePeers: {},\n            meetingUserDetails: {},\n            MUTE_CHANNEL: false\n        }\n    }\n\n    componentDidMount() {\n        if (this.props.match.params && this.props.match.params.meetingId) {\n            this.loadMeeting(this.props.match.params.meetingId);\n        }\n    }\n\n    setFocusedPeer = (key) => {\n        const {DEFAULT_CHANNEL, MUTE_CHANNEL} = this.state;\n\n        if (!this.state.is_admin) {\n            displayMessage(WARNING_MSG_TYPE, \"You are not allowed for this action.\");\n            return false;\n        }\n        this.setState({\n            focusedPeer: key\n        })\n        signalingSocket.send({admin: key, peer_id: 'admin', channel: DEFAULT_CHANNEL, mute: MUTE_CHANNEL});\n    }\n\n    toggleChannelMute = (adminKey) => {\n        const {DEFAULT_CHANNEL, MUTE_CHANNEL} = this.state;\n        if (!this.state.is_admin) {\n            displayMessage(WARNING_MSG_TYPE, \"You are not allowed for this action.\");\n            return false;\n        }\n        signalingSocket.send({admin: null, peer_id: 'admin', channel: DEFAULT_CHANNEL, mute: !MUTE_CHANNEL});\n    }\n\n    loadMeeting = (meetingId) => {\n        const that = this;\n        const successFn = function (data) {\n            let admin = false;\n            data.admins.forEach(function (doctor) {\n                if (that.props.user.staff && that.props.user.staff.id == doctor) {\n                    admin = true;\n                }\n            });\n            that.setState({\n                meetingDetails: data,\n                is_admin: admin,\n            });\n            that.changeChannel(data.meeting_id);\n        }\n        const errorFn = function () {\n\n        }\n        getAPI(interpolate(SINGLE_MEETING, [meetingId]), successFn, errorFn);\n    }\n\n    changeChannel = (value) => {\n        value = value || 'default';\n        const that = this;\n        this.setState({\n            DEFAULT_CHANNEL: value,\n        }, function () {\n            that.init();\n        })\n    }\n\n    init = () => {\n        const that = this;\n        console.log(\"Connecting to signaling server\");\n        const {SIGNALING_SERVER, DEFAULT_CHANNEL, ICE_SERVERS, MUTE_CHANNEL} = this.state;\n        signalingSocket = io(SIGNALING_SERVER);\n        // signalingSocket = io();\n        signalingSocket.on('message', function (data) {\n            console.log(\"userDetails\", data);\n            console.log(\"admin\", data.admin);\n            that.setState({\n                meetingUserDetails: data,\n                MUTE_CHANNEL: data.mute\n            })\n        });\n        signalingSocket.on('connect', function () {\n            console.log(\"Connected to signaling server\");\n            that.setupLocalMedia(function () {\n                /* once the user has given us access to their\n                 * microphone/camcorder, join the channel and start peering up */\n                join_chat_channel(DEFAULT_CHANNEL, {'whatever-you-want-here': 'stuff'});\n            });\n        });\n        signalingSocket.on('disconnect', function () {\n            console.log(\"Disconnected from signaling server\");\n            /* Tear down all of our peer connections and remove all the\n             * media divs when we disconnect */\n            // for (peer_id in peerMediaElements) {\n            //     peerMediaElements[peer_id].remove();\n            // }\n            // for (peer_id in peers) {\n            //     peers[peer_id].close();\n            // }\n\n            peers = {};\n            peerMediaElements = {};\n        });\n\n        function join_chat_channel(channel, userdata) {\n            signalingSocket.emit('join', {\"channel\": channel, \"userdata\": userdata});\n        }\n\n        function part_chat_channel(channel) {\n            signalingSocket.emit('part', channel);\n        }\n\n\n        /**\n         * When we join a group, our signaling server will send out 'addPeer' events to each pair\n         * of users in the group (creating a fully-connected graph of users, ie if there are 6 people\n         * in the channel you will connect directly to the other 5, so there will be a total of 15\n         * connections in the network).\n         */\n        signalingSocket.on('addPeer', function (config) {\n            console.log('Signaling server said to add peer:', config);\n            const {peer_id} = config;\n            if (peer_id in peers) {\n                /* This could happen if the user joins multiple channels where the other peer is also in. */\n                console.log(\"Already connected to peer \", peer_id);\n                return;\n            }\n            const peer_connection = new RTCPeerConnection(\n                {\"iceServers\": ICE_SERVERS},\n                {\"optional\": [{\"DtlsSrtpKeyAgreement\": true}]} /* this will no longer be needed by chrome\n                                                                        * eventually (supposedly), but is necessary\n                                                                        * for now to get firefox to talk to chrome */\n            );\n            console.log(\"New Peer Connection\", peer_connection);\n            peers[peer_id] = peer_connection;\n\n\n            peer_connection.onicecandidate = function (event) {\n                if (event.candidate) {\n                    signalingSocket.emit('relayICECandidate', {\n                        'peer_id': peer_id,\n                        'ice_candidate': {\n                            'sdpMLineIndex': event.candidate.sdpMLineIndex,\n                            'candidate': event.candidate.candidate\n                        }\n                    });\n                }\n            }\n            peer_connection.onaddstream = function (event) {\n                console.log(\"onAddStream\", event);\n                const remote_media = (\n                    <video\n                      key={peer_id}\n                      ref={video => {\n                            if (video)\n                                video.srcObject = event.stream\n                        }}\n                      autoPlay\n                      controls\n                      muted={MUTE_CHANNEL}\n                      style={{width: '100%'}}\n                    />\n                );\n                peerMediaElements[peer_id] = remote_media;\n                that.setState(function (prevState) {\n                    return {availablePeers: {...prevState.availablePeers, [peer_id]: true}}\n                })\n            }\n            /* Add our local stream */\n            peer_connection.addStream(localMediaStream);\n\n\n            /* Only one side of the peer connection should create the\n             * offer, the signaling server picks one to be the offerer.\n             * The other user will get a 'sessionDescription' event and will\n             * create an offer, then send back an answer 'sessionDescription' to us\n             */\n            if (config.should_create_offer) {\n                console.log(\"Creating RTC offer to \", peer_id);\n                peer_connection.createOffer(\n                    function (local_description) {\n                        console.log(\"Local offer description is: \", local_description);\n                        peer_connection.setLocalDescription(local_description,\n                            function () {\n                                signalingSocket.emit('relaySessionDescription',\n                                    {'peer_id': peer_id, 'session_description': local_description});\n                                console.log(\"Offer setLocalDescription succeeded\");\n                            },\n                            function () {\n                                displayMessage(ERROR_MSG_TYPE, \"Offer setLocalDescription failed!\");\n                            }\n                        );\n                    },\n                    function (error) {\n                        console.log(\"Error sending offer: \", error);\n                    });\n            }\n        });\n\n\n        /**\n         * Peers exchange session descriptions which contains information\n         * about their audio / video settings and that sort of stuff. First\n         * the 'offerer' sends a description to the 'answerer' (with type\n         * \"offer\"), then the answerer sends one back (with type \"answer\").\n         */\n        signalingSocket.on('sessionDescription', function (config) {\n            console.log('Remote description received: ', config);\n            const {peer_id} = config;\n            const peer = peers[peer_id];\n            const remote_description = config.session_description;\n            console.log(config.session_description);\n            const userData = {...that.props.user, peer_id, channel: DEFAULT_CHANNEL, mute: MUTE_CHANNEL};\n            if (that.state.is_admin || userData.is_superuser) {\n                userData.admin = true;\n                signalingSocket.send({admin: peer_id, peer_id: 'admin', channel: DEFAULT_CHANNEL, mute: MUTE_CHANNEL});\n            }\n            that.setState({\n                myPeerId: config.peer_id\n            })\n            signalingSocket.send(userData);\n            const desc = new RTCSessionDescription(remote_description);\n            const stuff = peer.setRemoteDescription(desc,\n                function () {\n                    console.log(\"setRemoteDescription succeeded\");\n                    if (remote_description.type == \"offer\") {\n                        console.log(\"Creating answer\");\n                        peer.createAnswer(\n                            function (local_description) {\n                                console.log(\"Answer description is: \", local_description);\n                                peer.setLocalDescription(local_description,\n                                    function () {\n                                        signalingSocket.emit('relaySessionDescription',\n                                            {'peer_id': peer_id, 'session_description': local_description});\n                                        console.log(\"Answer setLocalDescription succeeded\");\n                                    },\n                                    function () {\n                                        displayMessage(ERROR_MSG_TYPE, \"Answer setLocalDescription failed!\");\n                                    }\n                                );\n                            },\n                            function (error) {\n                                console.log(\"Error creating answer: \", error);\n                                console.log(peer);\n                            });\n                    }\n                },\n                function (error) {\n                    console.log(\"setRemoteDescription error: \", error);\n                }\n            );\n            console.log(\"Description Object: \", desc);\n\n        });\n\n        /**\n         * The offerer will send a number of ICE Candidate blobs to the answerer so they\n         * can begin trying to find the best path to one another on the net.\n         */\n        signalingSocket.on('iceCandidate', function (config) {\n            const peer = peers[config.peer_id];\n            const {ice_candidate} = config;\n            peer.addIceCandidate(new RTCIceCandidate(ice_candidate));\n        });\n\n\n        /**\n         * When a user leaves a channel (or is disconnected from the\n         * signaling server) everyone will recieve a 'removePeer' message\n         * telling them to trash the media channels they have open for those\n         * that peer. If it was this client that left a channel, they'll also\n         * receive the removePeers. If this client was disconnected, they\n         * wont receive removePeers, but rather the\n         * signalingSocket.on('disconnect') code will kick in and tear down\n         * all the peer sessions.\n         */\n        signalingSocket.on('removePeer', function (config) {\n            console.log('Signaling server said to remove peer:', config);\n            const {peer_id} = config;\n            // if (peer_id in peerMediaElements) {\n            peerMediaElements[peer_id] = <video src=\"\" />;\n            // }\n            // if (peer_id in peers) {\n            peers[peer_id].close();\n            // }\n            //\n            delete peers[peer_id];\n            delete peerMediaElements[config.peer_id];\n            that.setState(function (prevState) {\n                const availablePeers = {...prevState.availablePeers};\n                delete availablePeers[peer_id];\n                return {availablePeers: {...availablePeers}}\n            }, function () {\n\n            });\n\n        });\n    }\n\n\n    /** ******************** */\n    /** Local media stuff * */\n    /** ******************** */\n    setupLocalMedia = (callback, errorback) => {\n        const that = this;\n        if (localMediaStream != null) {  /* ie, if we've already been initialized */\n            if (callback) callback();\n            return;\n        }\n        /* Ask user for permission to use the computers microphone and/or camera,\n         * attach it to an <audio> or <video> tag if they give us access. */\n        console.log(\"Requesting access to local audio / video inputs\");\n\n\n        navigator.getUserMedia = (navigator.getUserMedia ||\n            navigator.webkitGetUserMedia ||\n            navigator.mozGetUserMedia ||\n            navigator.msGetUserMedia);\n\n\n        navigator.getUserMedia({\"audio\": true, \"video\": true},\n            function (stream) { /* user accepted access to a/v */\n                console.log(\"Access granted to audio/video\");\n                localMediaStream = stream;\n                const localMedia = (\n                    <video\n                      key=\"me\"\n                      muted\n                      autoPlay\n                      style={{width: '100%'}}\n                      ref={video => {\n                            if (video)\n                                video.srcObject = stream\n                        }}\n                    />\n                );\n                that.setState({\n                    localMediaComponent: localMedia\n                })\n\n                if (callback) callback();\n            },\n            function () { /* user denied access to a/v */\n                console.log(\"Access denied for audio/video\");\n                alert(\"You chose not to provide access to the camera/microphone, demo will not work.\");\n                if (errorback) errorback();\n            });\n    }\n\n    render() {\n        const {localMediaComponent, availablePeers, meetingUserDetails, meetingDetails, myPeerId,MUTE_CHANNEL} = this.state;\n        const availablePeersIdArray = Object.keys(availablePeers);\n        return (\n            <div style={{minHeight: '100vh', textAlign: 'center'}}>\n                <h3>{meetingDetails.name}</h3>\n                <Row type=\"flex\" justify=\"center\" gutter={16} style={{marginTop: 10}}>\n                    {meetingUserDetails.me && meetingUserDetails.me.socket === meetingUserDetails.admin ? (\n                        <Col xs={24} sm={12} md={12} lg={12} xl={12} key={myPeerId}>\n                            <Card bodyStyle={{padding: 0, textAlign: 'center'}}>\n                                {localMediaComponent}\n                                <h4>{meetingUserDetails[meetingUserDetails.admin] ? meetingUserDetails[meetingUserDetails.admin].first_name : '--'} </h4>\n                            </Card>\n                        </Col>\n                    ) : availablePeersIdArray.map(key => {\n                        if (meetingUserDetails.admin === key)\n                            return (\n                                <Col xs={24} sm={12} md={12} lg={12} xl={12} key={key}>\n                                    <Card bodyStyle={{padding: 0, textAlign: 'center'}}>\n                                        {peerMediaElements[key]}\n                                        <h4>{meetingUserDetails[key] ? meetingUserDetails[key].first_name : '--'}</h4>\n                                        <h2>\n                                            <Button.Group>\n                                                <Button\n                                                  type={this.state.MUTE_CHANNEL ? \"danger\" : \"primary\"}\n                                                  icon=\"audio\"\n                                                  onClick={this.toggleChannelMute}\n                                                >\n                                                    {this.state.MUTE_CHANNEL}\n                                                </Button>\n                                                <Button\n                                                  type=\"danger\"\n                                                  icon=\"close\"\n                                                  onClick={() => this.setFocusedPeer(meetingUserDetails.me ? meetingUserDetails.me.socket : null)}\n                                                />\n                                            </Button.Group>\n                                        </h2>\n                                    </Card>\n                                </Col>\n                            );\n                        return null;\n                    })}\n                    {/* {focusedPeer ? <Col xs={24} sm={12} md={12} lg={12} xl={12} key={focusedPeer}> */}\n                    {/*        <Card bodyStyle={{padding: 0, textAlign: 'center'}}> */}\n                    {/*            {peerMediaElements[focusedPeer]} */}\n                    {/*            <h4>{meetingUserDetails[focusedPeer] ? meetingUserDetails[focusedPeer].first_name : '--'} */}\n                    {/*                <Button type=\"danger\" shape=\"circle\" icon=\"close\" onClick={() => this.setFocusedPeer(myPeerId)} */}\n                    {/*                        style={{float: 'right'}}/> */}\n                    {/*            </h4> */}\n                    {/*        </Card> */}\n                    {/*    </Col> : */}\n                    {/*    null */}\n                    {/* } */}\n                </Row>\n                <Row gutter={16} style={{marginTop: 10}} type=\"flex\" justify=\"center\">\n                    <Col xs={24} sm={12} md={4} lg={4} xl={3}>\n                        <Card key=\"me\" bodyStyle={{padding: 0, textAlign: 'center'}}>\n                            {localMediaComponent}\n                            <h4> <Icon theme=\"twoTone\" type=\"audio\" twoToneColor={MUTE_CHANNEL?\"#f00\":\"#0f0\"} /> ME</h4>\n                        </Card>\n                    </Col>\n                    {availablePeersIdArray.map(key => {\n                        const mediaElement = peerMediaElements[key];\n                        // mediaElement.muted = MUTE_CHANNEL;\n                        return (\n                            <Col xs={8} sm={8} md={4} lg={4} xl={3} key={key} onClick={() => this.setFocusedPeer(key)}>\n                                <Card bodyStyle={{padding: 0, textAlign: 'center'}}>{mediaElement}\n                                    <h4> <Icon theme=\"twoTone\" type=\"audio\" twoToneColor={MUTE_CHANNEL?\"#f00\":\"#0f0\"} /> {meetingUserDetails[key] ? meetingUserDetails[key].first_name : '--'}</h4>\n                                </Card>\n                            </Col>\n                        )\n                    })}\n                </Row>\n            </div>\n        )\n    }\n\n}\n"],"sourceRoot":""}